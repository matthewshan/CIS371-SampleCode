import React from 'react'
import AuthorForm from './AuthorForm'
import AuthorList from './AuthorList'
import API from '../API'
import PropTypes from 'prop-types'

function ErrorMessage ({ message }) {
  return <div className='errorMessage'>{message}</div>
}

ErrorMessage.propTypes = {
  message: PropTypes.string.isRequired
}

export default function Authors () {
  const [authorList, setAuthorList] = React.useState([])
  const [loadingMessage, setLoadingMessage] = React.useState('Loading...')
  const [errorMessage, setErrorMessage] = React.useState(null)

  const [formMode, setFormMode] = React.useState('new')

  const emptyAuthor = { fname: '', lname: '', email: '' }
  const [currentAuthor, setCurrentAuthor] = React.useState(emptyAuthor)

  // Note:  The {} around API.fetchAuthors are important so that the block
  // passed to useEffect returns undefined (instead of the promise generated by fetch).
  React.useEffect(() => {
    API.fetchAuthors().then(data => {
      setAuthorList(data)
      setLoadingMessage(null)
    }).catch((message) => {
      setLoadingMessage('Unable to load authors because ' + message)
    })
  }, [])

  const updateAuthor = (field, value) => {
    const newAuthor = { ...currentAuthor }
    newAuthor[field] = value
    setCurrentAuthor(newAuthor)
  }

  const formSubmitted = () => {
    setErrorMessage(null)
    if (formMode === 'new') {
      API.postNewAuthor(currentAuthor).then(data => {
        console.log('Received data')
        console.log(data)
        if (data.id) {
          currentAuthor.id = data.id
          setCurrentAuthor(emptyAuthor)
          setAuthorList([...authorList, currentAuthor])
        } else {
          console.log("New author wasn't created.")
        }
      }).catch(message => setErrorMessage(`Failed to create new author: ${message}`))
    } else {
      API.updateAuthor(currentAuthor).then(() => {
        const newAuthorList = [...authorList]
        const authorIndex = authorList.findIndex((author) => author.id === currentAuthor.id)

        newAuthorList[authorIndex] = currentAuthor
        setAuthorList(newAuthorList)
      }).catch(message => setErrorMessage(`Failed to update author: ${message}`))
    }
  }

  const editClicked = (author) => {
    setErrorMessage(null)
    setFormMode('update')
    setCurrentAuthor(author)
  }

  const cancelClicked = () => {
    setErrorMessage(null)
    setFormMode('new')
    setCurrentAuthor(emptyAuthor)
  }

  const deleteClicked = (id) => {
    API.deleteAuthor(id).then(() => {
      setAuthorList(authorList.filter((item) => item.id !== id))
      cancelClicked()
    }).catch(message => setErrorMessage(`Failed to delete author: ${message}`))
  }

  const errorBlock = errorMessage ? <ErrorMessage message={errorMessage} /> : null

  return (
    <div className="authors">
      {errorBlock}
      <AuthorForm formMode={formMode} author={currentAuthor} updateAuthor={updateAuthor}
        submitCallback={formSubmitted} cancelCallback={cancelClicked} />
      {loadingMessage
        ? <p id='loading-message'>{loadingMessage}</p>
        : <AuthorList authors={authorList} onEditClicked={editClicked} onDeleteClicked={deleteClicked} />
      }
    </div>
  )
}
